###### Позиционные аргументы и обращение к переменным

Shell Bourne может принимать только 9 позиционных параметра.
Bash может больше, только обращаться нужно к ним через фигурные скобки `${12}`

`shift N` сдвигает позиционные параметры в минус N позицию, тем самым удаляя их.

`$*` - все аргументы объединяются в одну строку через пробел
`$@` - все аргументы объединяются в массив
`$#` - число позиционных параметров
`$0` - путь к текущему bash скрипту или к имени shell оболочки, если в интерактивном режиме
`$$` - PID текущего процесса
`$?` - код завершения последней выполненной команды
`$_` - последний аргумент последней выполненной команды
`$!` - PID последнего процесса запущенного в фоновом режиме
`$-` - активные флаги shell оболочки

`echo` - нужно использовать только в простых случаях, для остальных лучше использовать `printf`, чтобы быть
уверенным в воспроизведении результата.

###### Управляющие последовательности:
`\b` - Backspace
`\n` - Newline
`\r` - Carriage return
`\t` - Horizontal tab
`\v` - Vertical tab
`\\` - Backslash
`\nnn` - A character specified by one to three octal digits
`\xHH` - A character specified by one or two hexadecimal digits

###### Спецификаторы:
`%s` - строка
`%b` - строка, но управляющие последовательности из аргумента подставляются в шаблон
`%d` - целое число (десятичная, восьмеричная или шестнадцатеричная система), которое печатается в десятичной
`%f` - нецелое число десятичная система
`%x` - вывод десятичного числа в шестнадцатеричной системе
`%X` - вывод десятичного числа в шестнадцатеричной системе

```bash
printf "%s\n" Print arguments on "separate\tlines"
```
```bash
printf "%b\n" "Hello\nworld" "12\tword"
```
```bash
LC_NUMERIC=C
printf "%d\n" 23 45 56.78 0xff 017 #017 - восьмеричная
```
```bash
LC_NUMERIC=C
printf "%f " 12.34 23 56.789 1.2345678
```

```bash
printf "color: #%02X%02X%02X;\n" 255 0 255
```

###### Спецификаторы ширины:
`-15s` - минимальная ширина строки. Выравнивание по левому краю
`15s` - минимальная ширина строки. Выравнивание по правому краю
`04d` - минимальная ширина заполненная нулями для чисел
`12.4s` - минимальная ширина 12, максимальная 4(обрезка значения до 4)
`9.2f` - минимальная ширина 9, 2 знака после запятой

```bash
printf "'%-15s'\n" first second third fourth fifth sixth
printf "'%15s'\n" first second third fourth fifth sixth
printf "%04d\n" 12 23 56 123 255
printf "'%-12.4s'\n" John Jackson Walter
printf "'%12.4s'\n" John Jackson Walter
LC_NUMERIC=C
printf "'%9.2f'\n" 2 4.579 2.9
```

###### Сохранение в переменную
```bash
printf -v num4 "%04d" 4
printf "%s\n" "$num4"
```

###### Игнорирование переноса строки
`\`

###### Стандартные потоки
stdin - 0
stdout - 1
stderr - 2

###### Перенаправление
`>` - перенаправляет поток вывода в файл, очищая его перед этим
`>>` - дописывает в файл
`2>` - перенаправляет поток ошибок в файл
`2>&1` - перенаправляет поток ошибок в поток вывода
`>&2` - перенаправляет вывод в поток ошибок
`&>` - перенаправляет поток вывода и поток ошибок в файл
`&>>` - дописывает из потока вывода и потока ошибок в файл
`<` - перенаправляет файл на стандартный ввод
`<<EOF ...\n EOF` - отправляет файл написанный в коде на стандартный ввод
```<<<``` - отправляет одну строчку на стандартный ввод
`exec 1>outputfile.txt` - с момента вызова перенаправляет весь вывод скрипта в файл
`exec 0<inputfile.txt` - с момента вызова команда ожидающая ввод будет получать его из файла
`exec 2>errorfile.txt` - с момента вызова перенаправляет все ошибки в файл

```bash
printf '%s\n%v\n' OK? Oops! 1> FILE 2> ERRORFILE
```

```bash
printf '%s\n%v\n' OK? Oops! 1>FILE 2>&1
printf '%s\n%v\n' OK? Oops! &>FILE
printf '%s\n%v\n' OK? Oops! &>>FILE

```

```bash
echo
awk '/#/' <report.sh
echo =
awk '/#/' report.sh
```

```bash
(
  exec 1>file.txt
  echo "Mama"
  echo "Papa"
  echo "Daughter"
)

(
  exec 0<file.txt
  awk '/m/ || /p/ || /D/'
)
```

###### Чтение ввода
Если параметров больше, чем ввод читает, последний аргумент берёт на себя все оставшиеся слова.
`read -r` воспринимает перенос строки `\` буквально
```bash
read a b c d
echo $a
echo $b
echo $c
echo $d
```

Читает первую строку файла
```bash
read a b c <file.txt
echo $a 
echo $b
echo $c
echo $d
```

###### Конвейеры Pipelines
`tee` читает ввод и перенаправляет в файлы помимо того, что перенаправляет на вывод
```bash
printf "%s\n" "$RANDOM" "$RANDOM" "$RANDOM" "$RANDOM" | tee file.txt | grep 2
```

###### Подстановка команд
Подстановка должна быть использована только с внешними командами, а не с внутренними, так как со встроенными это
работает медленно.
`tr` -меняет символы
```bash
type date
data=`date`
data2=$(date)
echo "$data"
echo "$data2" | tr 2 3 | tr 3 4
```

