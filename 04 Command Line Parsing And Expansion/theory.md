###### Цитирование
```bash
./sa \ this "is a" 'demonstration of' \ quotes\ and\ escapes
# \ this - | this|
# "is a" - |is a|
# 'demonstration of' = |demonstration of|
# \ quotes\ and\ escapes - | quotes and escapes|

```
Внутри одинарных кавычек двойные кавычки имеют буквальное значение. В одинарных кавычках экранированная кавычка не
работает. В одинарных кавычках весь текст понимается буквально, символ экранирования понимается буквально.
В одинарных кавычках можно применять одинарные кавычки, если перед начало поставить $ и экранировать одинарные кавычки.

Внутри двойных кавычек одинарные кавычки имеют буквальное значение. Можно применить двойные кавычки внутри двойных, если
их экранировать.

```bash
./sa "a double-quoted single quote, '" "a double-quoted double quote, \""
./sa 'a single-quoted double quotation mark, "'
./sa "First argument "'still the first argument'
./sa 'First argument ''still the first argument'
./sa "First argument ""still the first argument"
echo $'\'line1\'\n\'line2\''
./sa $'\'line1\'\n\'line2\''
./sa "Argument containing
a newline"

```

###### Распаковка фигурными скобками
```bash
./sa {one,two,three}
./sa {1..4}
./sa {4..1}
./sa {a..d}
./sa {d..a}
./sa {а..я}             # Кириллица не  поддерживается
./sa abc{a..d}efg       # Работает
./sa {{1..3},{a..c}}    # Вложенные "{}", раскрываются как одни
./sa {1..2}{a..b}{y..z} # Все возможные варианты (2*2*2)
./sa {001..13..4}       # Форматирование и шаг
./sa {c..k..4}          # С буквами шаг тоже работает

```

###### Распаковка тильдой
`~` - возвращает home директорию

```bash
./sa ~
./sa ~root
./sa ~vazh2100
./sa "~"     # Не работает
./sa "~root" # Не работает
./sa ~ciadpi

```

###### Распаковка параметров и переменных
```bash
var="whatever"
./sa "$var"
var=qwerty
./sa "${var}"

```
Повтор:
Shell Bourne может принимать только 9 позиционных параметра.
Bash может больше, только обращаться нужно к ним через фигурные скобки `${12}`

```bash
first=Jane
last=Johnson
./sa "$first_$last" "${first}_$last" # Переменная first_ не объявлена, поэтому пусто

```

###### Распаковка арифметических выражений
```bash
./sa "$((1 + 12))" "$((12 * 13))" "$((16 / 4))" "$((6 - 9))" "$((11 % 2))" "$(((1 + 1 + 1) * 2))"

```

###### Операторы арифметических выражений в порядке приоритета выполнения
`-`  - Унарный минус
`!`  - Логическое отрицание
`~`  - Побитовое отрицание ~010 -> 101
`*`  - Умножение
`/`  - Деление
`%`  - Остаток от деления
`+`  - Сложение
`-`  - Вычитание
`<<` - Побитовый сдвиг влево 010 << 1 -> 100; умножение на 2^n
`>>` - Побитовый сдвиг вправо 010 >> 1 -> 001; деление на 2^n
`<`  - Сравнение
`<=` - __
`>`  - __
`>=` - __
`==` - __
`!=` - __
`&`  - Побитовый AND 111 & 101 = 101
`^`  - Побитовый XOR 111 ^ 101 = 010
`|`  - Побитовый OR 111 | 101 = 111
`&&` - Логический AND
`||` - Логический OR  
`=`  - Присваивание
`+=` - Присваивание + операция над собой
`-=` - __
`*=` - __
`/=` - __
`%=` - __
`<<=`- __
`>>=`- __
`&=` - __
`^=` - __

`**`   - возведение в степень
`id++` - использование переменной и увеличение на 1
`id--` - __
`++id` - увеличение на 1 и использование переменной
`–-id` 0 __

`expr ? expr1 : expr2` - тернарный оператор
`expr1, expr2`         - выражения в одну строчку

`2#0101` - запись числа в двоичном виде

```bash
((!(10 - 10)))      # Отрицание. 10 - 10 = 0 -> false,  не false -> true
echo $?             # exit code 0 - true
echo $((~100))      # -101
echo $((011 & 011)) #
echo $((3 ** 3))    #

echo "$((1 != 1 ? 2 + 2 : 4 + 4))"
echo "$((2#0101 + 2#00101))"

echo "$((a = 5, b = 7, b - a))"

```

```bash
./sa "$((3 + 4 * 5))" "$(((3 + 4) * 5))"
./sa "$((13 % 5))"

```

```bash
sec=0
while true; do
  ./secs2dhms.sh "$((sec++))"
  sleep 1
done

```

###### Распаковка подстановки результата выполнения команды

```bash
wc -l $(date +%Y-%m-%d).log

```

###### Разделение слов
Если значение переменной передать в другую программу без кавычек, то текст будет разделён пробелами на аргументы
```bash
var="this is a multi-word value"
./sa $var "$var"
```

В первом случае обрежутся все пробелы и получится 2 аргумента
```bash
var=' spaced
 out '
./sa $var "$var"

```

Каждый символ в IFS является самостоятельным разделителем
```bash
IFS='e:'
var="qwerty : uiop :: e:r " ## : :: delimits 2 empty fields
./sa $var
```

###### Распаковка имени/пути файла
Применяется wildcards*, в разделе 3
```bash
./sa /bin/h*
./sa /bin/*k
./sa th?ory.*

```
