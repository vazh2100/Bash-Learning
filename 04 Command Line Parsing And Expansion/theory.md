###### Цитирование
```bash
./sa \ this "is a" 'demonstration of' \ quotes\ and\ escapes
```
Внутри одинарных кавычек двойные кавычки имеют буквальное значение. В одинарных кавычках экранированная кавычка не
работает. В одинарных кавычках весь текст понимается буквально, символ экранирования понимается буквально.
В одинарных кавычках можно применять одинарные кавычки, если перед начало поставить $ и экранировать одинарные кавычки.

Внутри двойных кавычек одинарные кавычки имеют буквальное значение. Можно применить двойные кавычки внутри двойных, если
их экранировать.

```bash
./sa "a double-quoted single quote, '" "a double-quoted double quote, \""
./sa 'a single-quoted double quotation mark, "'
./sa "First argument "'still the first argument'
./sa 'First argument ''still the first argument'
./sa "First argument ""still the first argument"
echo $'\'line1\'\n\'line2\''
./sa $'\'line1\'\n\'line2\''
./sa "Argument containing
a newline"
```

###### Распаковка фигурными скобками
```bash
./sa {one,two,three} # ./sa one two three
./sa {1..4}
./sa {4..1}
./sa {a..d}
./sa {d..a}
./sa {а..я}             # Кириллица не  поддерживается
./sa abc{a..d}efg       # Работает
./sa {{1..3},{a..c}}    # Вложенные "{}" через запятую, раскладываются как одни фигурные. Kotlin fold
./sa {1..2}{a..b}{y..z} # Все возможные варианты (2*2*2)
./sa {001..13..4}       # Форматирование и шаг
./sa {c..k..4}          # С буквами шаг тоже работает
```

###### Распаковка тильдой
`~` - возвращает home директорию

```bash
./sa ~
./sa ~root
./sa ~vazh2100
./sa "~"     # Не работает
./sa "~root" # Не работает
./sa ~ciadpi
```

###### Распаковка параметров и переменных
```bash
var="whatever"
./sa "$var"
var=qwerty
./sa "${var}"
```
Повтор:
Shell Bourne может принимать только 9 позиционных параметров.
Bash может больше, только обращаться нужно к ним через фигурные скобки `${12}`

```bash
first=Jane
last=Johnson
./sa "$first_$last" "${first}_$last" # Переменная first_ не объявлена, поэтому пусто
```

###### Распаковка арифметических выражений
```bash
./sa "$((1 + 12))" "$((12 * 13))" "$((16 / 4))" "$((6 - 9))" "$((11 % 2))" "$(((1 + 1 + 1) * 2))"
```

###### Операторы арифметических выражений в порядке приоритета выполнения
`-`  - Унарный минус
`!`  - Логическое отрицание
`~`  - Побитовое отрицание ~010 -> 101
`*`  - Умножение
`/`  - Деление
`%`  - Остаток от деления
`+`  - Сложение
`-`  - Вычитание
`<<` - Побитовый сдвиг влево 010 << 1 -> 100; умножение на 2^n
`>>` - Побитовый сдвиг вправо 010 >> 1 -> 001; деление на 2^n
`<`  - Сравнение
`<=` - __
`>`  - __
`>=` - __
`==` - __
`!=` - __
`&`  - Побитовый AND 111 & 101 = 101
`^`  - Побитовый XOR 111 ^ 101 = 010
`|`  - Побитовый OR 111 | 101 = 111
`&&` - Логический AND
`||` - Логический OR  
`=`  - Присваивание
`+=` - Присваивание + операция над собой
`-=` - __
`*=` - __
`/=` - __
`%=` - __
`<<=`- __
`>>=`- __
`&=` - __
`^=` - __

`**`   - возведение в степень
`id++` - использование переменной и увеличение на 1
`id--` - __
`++id` - увеличение на 1 и использование переменной
`–-id` 0 __

`expr ? expr1 : expr2` - тернарный оператор
`expr1, expr2`         - выражения в одну строчку

`2#0101` - запись числа в двоичном виде

```bash
((!(10 - 10)))      # Отрицание. 10 - 10 = 0 -> false,  не false -> true
echo $?             # exit code 0 - true
echo $((~100))      # -101
echo $((011 & 011)) #
echo $((3 ** 3))    #

echo "$((1 != 1 ? 2 + 2 : 4 + 4))"
echo "$((2#0101 + 2#00101))"

echo "$((a = 5, b = 7, b - a))"
```

```bash
./sa "$((3 + 4 * 5))" "$(((3 + 4) * 5))"
./sa "$((13 % 5))"
```

```bash
sec=0
while true; do
  ./secs2dhms.sh "$((sec++))"
  sleep 1
done
```

###### Распаковка подстановки результата выполнения команды

```bash
wc -l $(date +%Y-%m-%d).log
```

###### Разделение слов
Если значение переменной передать в другую программу без кавычек, то текст будет разделён пробелами на аргументы
```bash
var="this is a multi-word value"
./sa $var "$var"
```

В первом случае обрежутся все пробелы и получится 2 аргумента
```bash
var=' spaced
 out '
./sa $var "$var"

```

Каждый символ в IFS является самостоятельным разделителем
```bash
IFS='e:'
var="qwerty : uiop :: e:r " ## : :: delimits 2 empty fields
./sa $var
```

###### Распаковка имени/пути файла
Применяется wildcards*, в разделе 3
```bash
./sa /bin/h*
./sa /bin/*k
./sa th?ory.*
./sa th[ed][os][wr]y.*
./sa "$#" "$(date "+%Y %m %d")" John\ Doe
```

###### Подстановка процесса
`<(command)` - делает из вывода команды временный файл. На месте вызова образуется имя файла. Удобно, если команда в
качестве аргумента ожидает файл.
`> >(command)` - Создаёт временный файл, в который записывается вывод, а command читает из этого
файла. Это подстановка процесса
`${totalsize:=5}` - если переменная не проинициализирована, то она инициализируется значением 5

```bash
while read a; do
  echo Записал
done
```

```bash
cat <(ls -l)
```

Из-за pipeline переменная total_size становится внутренней переменной цикла while и не доступна за пределами
```bash
cd ~
ls -l * | while read perms links owner group size month day time file; do
  printf "%10d %s\n" "$size" "$file"
  total_size=$((total_size + ${size:-0}))
done
echo "${total_size-unset}" #  unset
```

Подстановка процесса позволяет решить эту проблему. Создаётся файл и отдаётся на ввод "<" команде `read`. `read` читает,
пока есть, что читать. Total size остаётся видимой переменой.
```bash
cd ~
while read perms links owner group size month day time file; do
  totalsize=$((${totalsize:=0} + ${size:-0}))
done < <(ls -l *)
echo ${totalsize-unset}
```

###### Распознавание опций в строке
`${0#/home/}` - `$0` получает полный путь к скрипту, `#` обрезает `/home/`, если путь начинается с `/home/`
`${0##*/}` - `$0` получает полный путь к скрипту, `##` обрезает начало строки, до самого последнего `/`. В итоге
получается просто имя файла
`while getopts "f:v" opt` читает по одной опции и сохраняет её в opt. Аналогично read var. `f:`, опция ожидающая
аргумент.
`$OPTARG` содержит переданное значение к аргументу, после чтения getopts
`$OPTIND` содержит номер ещё не прочитанной опции
`shift "$((OPTIND - 1))"` удаление всех переданных опций

```bash
./parse_options.sh -vf theory.md
```

```bash
name=vasyan
echo ${name#*a}
echo ${name##*a}
```

```bash
isVerbose=1
if ((isVerbose)); then
  echo "verbose"
fi
```

```bash
year=$(date +%Y)
month="$(date +%m)"
day="$(date +%d)"
hour="$(date +%H)"
minute="$(date +%M)"
second="$(date +%S)"

echo $year $month $day $hour $minute $second
```